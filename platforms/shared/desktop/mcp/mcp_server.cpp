/*
 * Geargrafx - PC Engine / TurboGrafx Emulator
 * Copyright (C) 2024  Ignacio Sanchez

 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * any later version.

 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.

 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see http://www.gnu.org/licenses/
 *
 */

#include "mcp_server.h"
#include "../utils.h"
#include <sstream>
#include <iomanip>
#include <fstream>
#include "log.h"

static void* ReaderThreadFunc(void* arg)
{
    McpServer* server = (McpServer*)arg;
    server->ReaderLoop();
    return NULL;
}

void McpServer::ReaderLoop()
{
    while (m_running.load())
    {
        std::string line;
        if (m_transport->recv(line))
        {
            if (!line.empty())
            {
                HandleLine(line);
            }
        }
        else
        {
            // EOF or error
            Stop();
            break;
        }
    }
}

void McpServer::Run()
{
    // Start reader thread for transport input
    std::thread reader_thread(ReaderThreadFunc, this);
    reader_thread.detach();

    // Transport thread waits for responses generated by the main thread
    // (via PumpCommands) and sends them back through the transport
    while (m_running.load())
    {
        DebugResponse* resp = m_responseQueue.WaitAndPop();
        if (resp == NULL)
            break;

        if (resp->isError)
        {
            SendError(resp->requestId, resp->errorCode, resp->errorMessage);
        }
        else
        {
            // Wrap result in MCP response format
            json mcpResult;
            mcpResult["content"] = json::array();

            // Check if this is image data (special marker from GetScreenshot)
            if (resp->result.contains("__mcp_image") && resp->result["__mcp_image"] == true)
            {
                // Image content type
                mcpResult["content"].push_back({
                    {"type", "image"},
                    {"data", resp->result["data"]},
                    {"mimeType", resp->result["mimeType"]}
                });
            }
            else
            {
                // Text content type (default)
                std::ostringstream result_ss;
                result_ss << resp->result.dump(2);

                mcpResult["content"].push_back({
                    {"type", "text"},
                    {"text", result_ss.str()}
                });
            }

            json response;
            response["jsonrpc"] = "2.0";
            response["id"] = resp->requestId;
            response["result"] = mcpResult;

            SendResponse(response);
        }

        SafeDelete(resp);
    }
}

void McpServer::HandleLine(const std::string& line)
{
    json request;

    // Try to parse JSON
    if (!json::accept(line))
    {
        SendError(0, -32700, "Parse error: Invalid JSON");
        return;
    }

    request = json::parse(line);

    // Validate JSON-RPC structure
    if (!request.contains("jsonrpc") || request["jsonrpc"] != "2.0")
    {
        SendError(0, -32600, "Invalid Request: missing or invalid jsonrpc version");
        return;
    }

    if (!request.contains("method") || !request["method"].is_string())
    {
        SendError(0, -32600, "Invalid Request: missing method");
        return;
    }

    std::string method = request["method"];

    // Handle different methods
    if (method == "initialize")
    {
        HandleInitialize(request);
    }
    else if (method == "notifications/initialized")
    {
        // Notifications don't need JSON-RPC response, but HTTP needs HTTP response
        if (dynamic_cast<HttpTransport*>(m_transport))
        {
            m_transport->send("{}");
        }
    }
    else if (method == "tools/list")
    {
        HandleToolsList(request);
    }
    else if (method == "tools/call")
    {
        HandleToolsCall(request);
    }
    else if (method == "resources/list")
    {
        HandleResourcesList(request);
    }
    else if (method == "resources/read")
    {
        HandleResourcesRead(request);
    }
    else
    {
        int64_t id = request.contains("id") ? request["id"].get<int64_t>() : 0;
        SendError(id, -32601, "Method not found: " + method);
    }
}

void McpServer::HandleInitialize(const json& request)
{
    if (!request.contains("id"))
    {
        SendError(0, -32600, "Invalid Request: missing id");
        return;
    }

    int64_t id = request["id"];

    // Get protocol version from request
    std::string protocolVersion = "2024-11-05";
    if (request.contains("params") && request["params"].contains("protocolVersion"))
    {
        protocolVersion = request["params"]["protocolVersion"];
    }

    json response;
    response["jsonrpc"] = "2.0";
    response["id"] = id;
    response["result"] = {
        {"protocolVersion", protocolVersion},
        {"capabilities", {
            {"tools", json::object()},
            {"resources", json::object()}
        }},
        {"serverInfo", {
            {"name", "geargrafx-mcp-server"},
            {"version", "1.0.0"}
        }}
    };

    m_initialized = true;
    SendResponse(response);
}

void McpServer::HandleToolsList(const json& request)
{
    if (!request.contains("id"))
    {
        SendError(0, -32600, "Invalid Request: missing id");
        return;
    }

    int64_t id = request["id"];

    json tools = json::array();

    // Execution control tools
    tools.push_back({
        {"name", "debug_pause"},
        {"description", "Pause Geargrafx PC Engine / TurboGrafx-16 emulator execution (break at current instruction)"},
        {"inputSchema", {
            {"type", "object"},
            {"properties", json::object()}
        }}
    });

    tools.push_back({
        {"name", "debug_continue"},
        {"description", "Resume Geargrafx emulator execution from current breakpoint"},
        {"inputSchema", {
            {"type", "object"},
            {"properties", json::object()}
        }}
    });

    tools.push_back({
        {"name", "debug_step_into"},
        {"description", "Step into next HuC6280 instruction (enters subroutines)"},
        {"inputSchema", {
            {"type", "object"},
            {"properties", json::object()}
        }}
    });

    tools.push_back({
        {"name", "debug_step_over"},
        {"description", "Step over next HuC6280 instruction (skips subroutines like JSR)"},
        {"inputSchema", {
            {"type", "object"},
            {"properties", json::object()}
        }}
    });

    tools.push_back({
        {"name", "debug_step_out"},
        {"description", "Step out of current subroutine (continues until RTS/RTI)"},
        {"inputSchema", {
            {"type", "object"},
            {"properties", json::object()}
        }}
    });

    tools.push_back({
        {"name", "debug_step_frame"},
        {"description", "Step one video frame (executes until next VBLANK on PC Engine)"},
        {"inputSchema", {
            {"type", "object"},
            {"properties", json::object()}
        }}
    });

    tools.push_back({
        {"name", "debug_reset"},
        {"description", "Reset the PC Engine / TurboGrafx-16 emulated system"},
        {"inputSchema", {
            {"type", "object"},
            {"properties", json::object()}
        }}
    });

    tools.push_back({
        {"name", "debug_get_status"},
        {"description", "Get current debugger status (paused: true/false, at_breakpoint: true/false, pc: logical address if at breakpoint)"},
        {"inputSchema", {
            {"type", "object"},
            {"properties", json::object()}
        }}
    });

    // Breakpoint tools
    tools.push_back({
        {"name", "set_breakpoint"},
        {"description", "Set a breakpoint at specified logical address in PC Engine memory (ROM/RAM, VRAM, Palette, or hardware registers)"},
        {"inputSchema", {
            {"type", "object"},
            {"properties", {
                {"address", {
                    {"type", "string"},
                    {"description", "Logical address in hex (e.g., '8000', '0x8000', '$8000')"}
                }},
                {"memory_area", {
                    {"type", "string"},
                    {"description", "Memory area: rom_ram (default), vram, palette, huc6270_reg, huc6260_reg"},
                    {"enum", json::array({"rom_ram", "vram", "palette", "huc6270_reg", "huc6260_reg"})}
                }},
                {"type", {
                    {"type", "string"},
                    {"description", "Breakpoint type: exec (default), read, write"},
                    {"enum", json::array({"exec", "read", "write"})}
                }}
            }},
            {"required", json::array({"address"})}
        }}
    });

    tools.push_back({
        {"name", "set_breakpoint_range"},
        {"description", "Set a breakpoint for a logical address range"},
        {"inputSchema", {
            {"type", "object"},
            {"properties", {
                {"start_address", {
                    {"type", "string"},
                    {"description", "Start logical address in hex (e.g., '8000')"}
                }},
                {"end_address", {
                    {"type", "string"},
                    {"description", "End logical address in hex (e.g., '8FFF')"}
                }},
                {"memory_area", {
                    {"type", "string"},
                    {"description", "Memory area: rom_ram, vram, palette, huc6270_reg, huc6260_reg"},
                    {"enum", json::array({"rom_ram", "vram", "palette", "huc6270_reg", "huc6260_reg"})}
                }},
                {"type", {
                    {"type", "string"},
                    {"description", "Breakpoint type: exec, read, write"},
                    {"enum", json::array({"exec", "read", "write"})}
                }}
            }},
            {"required", json::array({"start_address", "end_address"})}
        }}
    });

    tools.push_back({
        {"name", "remove_breakpoint"},
        {"description", "Clear a breakpoint. Single address: provide 'address' only. Range: provide both 'address' and 'end_address' matching the exact range. Uses logical addresses."},
        {"inputSchema", {
            {"type", "object"},
            {"properties", {
                {"address", {
                    {"type", "string"},
                    {"description", "Logical address in hex (e.g., '8000'). For ranges: the start address"}
                }},
                {"end_address", {
                    {"type", "string"},
                    {"description", "Logical end address in hex (e.g., '8FFF'). Required only for range breakpoints. Must match the end address used when creating the range"}
                }},
                {"memory_area", {
                    {"type", "string"},
                    {"description", "Memory area: rom_ram, vram, palette, huc6270_reg, huc6260_reg"},
                    {"enum", json::array({"rom_ram", "vram", "palette", "huc6270_reg", "huc6260_reg"})}
                }},
                {"type", {
                    {"type", "string"},
                    {"description", "Breakpoint type: exec, read, write"},
                    {"enum", json::array({"exec", "read", "write"})}
                }}
            }},
            {"required", json::array({"address"})}
        }}
    });

    tools.push_back({
        {"name", "list_breakpoints"},
        {"description", "List all breakpoints"},
        {"inputSchema", {
            {"type", "object"},
            {"properties", json::object()}
        }}
    });

    // Memory tools
    tools.push_back({
        {"name", "list_memory_areas"},
        {"description", "List memory editor tabs (physical memory spaces like WRAM, VRAM, ROM banks). Each area has 0-based offsets (though CPU may accesses them at different logical addresses)."},
        {"inputSchema", {
            {"type", "object"},
            {"properties", json::object()}
        }}
    });

    tools.push_back({
        {"name", "read_memory"},
        {"description", "Read memory from a specific memory area"},
        {"inputSchema", {
            {"type", "object"},
            {"properties", {
                {"area", {
                    {"type", "integer"},
                    {"description", "Memory editor tab ID (use list_memory_areas to get IDs and physical offsets)"}
                }},
                {"offset", {
                    {"type", "string"},
                    {"description", "0-based hex offset within the physical memory area (e.g., '0100' for byte 256 of that space)"}
                }},
                {"size", {
                    {"type", "integer"},
                    {"description", "Number of bytes to read"}
                }}
            }},
            {"required", json::array({"area", "offset", "size"})}
        }}
    });

    tools.push_back({
        {"name", "write_memory"},
        {"description", "Write memory to a specific memory area"},
        {"inputSchema", {
            {"type", "object"},
            {"properties", {
                {"area", {
                    {"type", "integer"},
                    {"description", "Memory editor tab ID (use list_memory_areas to get IDs and physical offsets)"}
                }},
                {"offset", {
                    {"type", "string"},
                    {"description", "0-based hex offset within the physical memory area (e.g., '0100' for byte 256 of that space)"}
                }},
                {"bytes", {
                    {"type", "string"},
                    {"description", "Hex bytes separated by spaces (e.g., 'A9 00 85 10')"}
                }}
            }},
            {"required", json::array({"area", "offset", "bytes"})}
        }}
    });

    // Register tools
    tools.push_back({
        {"name", "write_huc6280_register"},
        {"description", "Write to a HuC6280 CPU register"},
        {"inputSchema", {
            {"type", "object"},
            {"properties", {
                {"name", {
                    {"type", "string"},
                    {"description", "Register name (PC, A, X, Y, S, P)"}
                }},
                {"value", {
                    {"type", "string"},
                    {"description", "Hex value"}
                }}
            }},
            {"required", json::array({"name", "value"})}
        }}
    });

    // Disassembly tool
    tools.push_back({
        {"name", "get_disassembly"},
        {"description", "Get disassembled HuC6280 assembly code for a logical address range. "
                        "Returns: logical address, bank, segment, mnemonic, and raw bytes. "
                        "NOTE: Disassembled records only exist for code that has been executed during emulation."},
        {"inputSchema", {
            {"type", "object"},
            {"properties", {
                {"start_address", {
                    {"type", "string"},
                    {"description", "Start logical address in hex (required). Accepts formats: 'E177', '0xE177', '$E177'"}
                }},
                {"end_address", {
                    {"type", "string"},
                    {"description", "End logical address in hex (required). Must be >= start_address. Accepts formats: 'E177', '0xE177', '$E177'"}
                }},
                {"bank", {
                    {"type", "string"},
                    {"description", "Optional bank in hex (00-FF). When provided, overrides the current MPR mapping for address translation. "
                                    "The physical address is constructed as: (bank << 13) | (logical_address & 0x1FFF). "
                                    "Use this when you want to inspect a specific ROM/RAM bank regardless of current CPU memory mapping."}
                }}
            }},
            {"required", json::array({"start_address", "end_address"})}
        }}
    });

    // Media info tool
    tools.push_back({
        {"name", "get_media_info"},
        {"description", "Get information about the loaded PC Engine ROM or CD-ROM (file path, type, size, console type, mapper, BIOS paths, etc.)"},
        {"inputSchema", {
            {"type", "object"},
            {"properties", json::object()}
        }}
    });

    // Chip status tools
    tools.push_back({
        {"name", "get_huc6280_status"},
        {"description", "Get HuC6280 CPU status (registers, MPR, timer, interrupts, I/O, speed)"},
        {"inputSchema", {
            {"type", "object"},
            {"properties", json::object()}
        }}
    });

    tools.push_back({
        {"name", "get_huc6270_registers"},
        {"description", "Get all 20 HuC6270 VDC registers (0x00-0x13), Address Register, and Status Register. Use vdc parameter (1 or 2) for SuperGrafx"},
        {"inputSchema", {
            {"type", "object"},
            {"properties", {
                {"vdc", {
                    {"type", "integer"},
                    {"description", "VDC number (1 or 2 for SuperGrafx, default 1)"}
                }}
            }}
        }}
    });

    tools.push_back({
        {"name", "write_huc6270_register"},
        {"description", "Write to a HuC6270 VDC register (0-19) or Address Register (20). Use vdc parameter (1 or 2) for SuperGrafx. Status Register is read-only."},
        {"inputSchema", {
            {"type", "object"},
            {"properties", {
                {"register", {
                    {"type", "integer"},
                    {"description", "Register number (0-19 for data registers, 20 for Address Register)"},
                    {"minimum", 0},
                    {"maximum", 20}
                }},
                {"value", {
                    {"type", "string"},
                    {"description", "16-bit hex value (e.g., '1234', '0x1234', '$1234')"}
                }},
                {"vdc", {
                    {"type", "integer"},
                    {"description", "VDC number (1 or 2 for SuperGrafx, default 1)"}
                }}
            }},
            {"required", json::array({"register", "value"})}
        }}
    });

    tools.push_back({
        {"name", "get_huc6270_status"},
        {"description", "Get HuC6270 VDC status (position, state, control, interrupts). Use vdc parameter (1 or 2) for SuperGrafx"},
        {"inputSchema", {
            {"type", "object"},
            {"properties", {
                {"vdc", {
                    {"type", "integer"},
                    {"description", "VDC number (1 or 2 for SuperGrafx, default 1)"}
                }}
            }}
        }}
    });

    tools.push_back({
        {"name", "get_huc6260_status"},
        {"description", "Get HuC6260 VCE status (position, sync signals, control register, CTA, blur, B&W)"},
        {"inputSchema", {
            {"type", "object"},
            {"properties", json::object()}
        }}
    });

    tools.push_back({
        {"name", "get_huc6202_status"},
        {"description", "Get HuC6202 VPC status (only for SuperGrafx games - window priority, selected VDC, IRQ status)"},
        {"inputSchema", {
            {"type", "object"},
            {"properties", json::object()}
        }}
    });

    tools.push_back({
        {"name", "get_psg_status"},
        {"description", "Get PSG (Programmable Sound Generator) status for all 6 channels (frequency, amplitude, waveform, noise, DDA)"},
        {"inputSchema", {
            {"type", "object"},
            {"properties", json::object()}
        }}
    });

    tools.push_back({
        {"name", "get_cdrom_status"},
        {"description", "Get CD-ROM drive status (only for CD-ROM games)"},
        {"inputSchema", {
            {"type", "object"},
            {"properties", json::object()}
        }}
    });

    tools.push_back({
        {"name", "get_arcade_card_status"},
        {"description", "Get Arcade Card status (only for Arcade Card games)"},
        {"inputSchema", {
            {"type", "object"},
            {"properties", json::object()}
        }}
    });

    tools.push_back({
        {"name", "get_cdrom_audio_status"},
        {"description", "Get CD-ROM audio playback status (only for CD-ROM games)"},
        {"inputSchema", {
            {"type", "object"},
            {"properties", json::object()}
        }}
    });

    tools.push_back({
        {"name", "get_adpcm_status"},
        {"description", "Get ADPCM audio status (only for CD-ROM games)"},
        {"inputSchema", {
            {"type", "object"},
            {"properties", json::object()}
        }}
    });

    tools.push_back({
        {"name", "get_screenshot"},
        {"description", "Capture current PC Engine / TurboGrafx-16 screen frame as base64-encoded PNG image"},
        {"inputSchema", {
            {"type", "object"},
            {"properties", json::object()}
        }}
    });

    // Media and state management tools
    tools.push_back({
        {"name", "load_media"},
        {"description", "Load a ROM file or CD-ROM image (.pce, .sgx, .hes, .cue, .zip). Automatically loads .sym symbol file if present. Resets emulator on successful load"},
        {"inputSchema", {
            {"type", "object"},
            {"properties", {
                {"file_path", {
                    {"type", "string"},
                    {"description", "Absolute path to ROM or CD-ROM file"}
                }}
            }},
            {"required", json::array({"file_path"})}
        }}
    });

    tools.push_back({
        {"name", "load_symbols"},
        {"description", "Load debug symbols from file (.sym format with 'BANK:ADDRESS LABEL' entries). Adds to existing symbols"},
        {"inputSchema", {
            {"type", "object"},
            {"properties", {
                {"file_path", {
                    {"type", "string"},
                    {"description", "Absolute path to symbol file"}
                }}
            }},
            {"required", json::array({"file_path"})}
        }}
    });

    tools.push_back({
        {"name", "list_save_state_slots"},
        {"description", "List all 5 save state slots with their information (rom name, timestamp, screenshot availability)"},
        {"inputSchema", {
            {"type", "object"},
            {"properties", json::object()}
        }}
    });

    tools.push_back({
        {"name", "select_save_state_slot"},
        {"description", "Select active save state slot (1-5) for save_state and load_state operations"},
        {"inputSchema", {
            {"type", "object"},
            {"properties", {
                {"slot", {
                    {"type", "integer"},
                    {"description", "Slot number (1-5)"},
                    {"minimum", 1},
                    {"maximum", 5}
                }}
            }},
            {"required", json::array({"slot"})}
        }}
    });

    tools.push_back({
        {"name", "save_state"},
        {"description", "Save emulator state to currently selected slot (use select_save_state_slot to change)"},
        {"inputSchema", {
            {"type", "object"},
            {"properties", json::object()}
        }}
    });

    tools.push_back({
        {"name", "load_state"},
        {"description", "Load emulator state from currently selected slot (use select_save_state_slot to change)"},
        {"inputSchema", {
            {"type", "object"},
            {"properties", json::object()}
        }}
    });

    tools.push_back({
        {"name", "set_fast_forward_speed"},
        {"description", "Set fast forward speed multiplier (0: 1.5x, 1: 2x, 2: 2.5x, 3: 3x, 4: Unlimited)"},
        {"inputSchema", {
            {"type", "object"},
            {"properties", {
                {"speed", {
                    {"type", "integer"},
                    {"description", "Speed index (0-4)"},
                    {"minimum", 0},
                    {"maximum", 4}
                }}
            }},
            {"required", json::array({"speed"})}
        }}
    });

    tools.push_back({
        {"name", "toggle_fast_forward"},
        {"description", "Toggle fast forward mode on or off. When enabled, emulator runs at configured speed (see set_fast_forward_speed)"},
        {"inputSchema", {
            {"type", "object"},
            {"properties", {
                {"enabled", {
                    {"type", "boolean"},
                    {"description", "true to enable fast forward, false to disable"}
                }}
            }},
            {"required", json::array({"enabled"})}
        }}
    });

    // Controller input tools
    tools.push_back({
        {"name", "controller_button"},
        {"description", "Control a button on a controller (player 1-5). Use action 'press' to hold the button down, 'release' to let it go, or 'press_and_release' to simulate a quick button tap (presses and automatically releases after a few frames). Buttons: up, down, left, right, select, run, I, II, III, IV, V, VI"},
        {"inputSchema", {
            {"type", "object"},
            {"properties", {
                {"player", {
                    {"type", "integer"},
                    {"description", "Player number (1-5)"},
                    {"minimum", 1},
                    {"maximum", 5}
                }},
                {"button", {
                    {"type", "string"},
                    {"description", "Button name: up, down, left, right, select, run, I, II, III, IV, V, VI"},
                    {"enum", json::array({"up", "down", "left", "right", "select", "run", "I", "II", "III", "IV", "V", "VI"})}
                }},
                {"action", {
                    {"type", "string"},
                    {"description", "Action to perform: 'press' holds the button, 'release' lets it go, 'press_and_release' simulates a quick tap"},
                    {"enum", json::array({"press", "release", "press_and_release"})}
                }}
            }},
            {"required", json::array({"player", "button", "action"})}
        }}
    });

    tools.push_back({
        {"name", "controller_set_type"},
        {"description", "Set controller type for a player (1-5). Types: standard (2 buttons), avenue_pad_3 (3 buttons), avenue_pad_6 (6 buttons)"},
        {"inputSchema", {
            {"type", "object"},
            {"properties", {
                {"player", {
                    {"type", "integer"},
                    {"description", "Player number (1-5)"},
                    {"minimum", 1},
                    {"maximum", 5}
                }},
                {"type", {
                    {"type", "string"},
                    {"description", "Controller type"},
                    {"enum", json::array({"standard", "avenue_pad_3", "avenue_pad_6"})}
                }}
            }},
            {"required", json::array({"player", "type"})}
        }}
    });

    tools.push_back({
        {"name", "controller_set_turbo_tap"},
        {"description", "Enable or disable Turbo Tap (multitap) to allow 5 players. Disable for single player only"},
        {"inputSchema", {
            {"type", "object"},
            {"properties", {
                {"enabled", {
                    {"type", "boolean"},
                    {"description", "true to enable Turbo Tap (5 players), false for single player"}
                }}
            }},
            {"required", json::array({"enabled"})}
        }}
    });

    tools.push_back({
        {"name", "controller_get_type"},
        {"description", "Get the current controller type for a player (1-5). Returns: standard, avenue_pad_3, or avenue_pad_6"},
        {"inputSchema", {
            {"type", "object"},
            {"properties", {
                {"player", {
                    {"type", "integer"},
                    {"description", "Player number (1-5)"},
                    {"minimum", 1},
                    {"maximum", 5}
                }}
            }},
            {"required", json::array({"player"})}
        }}
    });

    tools.push_back({
        {"name", "list_sprites"},
        {"description", "List information for all 64 hardware sprites (position, size, pattern index, palette, flags). Use vdc parameter (1 or 2) for SuperGrafx dual VDC"},
        {"inputSchema", {
            {"type", "object"},
            {"properties", {
                {"vdc", {
                    {"type", "integer"},
                    {"description", "VDC number (1 or 2 for SuperGrafx, default 1)"}
                }}
            }}
        }}
    });

    tools.push_back({
        {"name", "get_sprite_image"},
        {"description", "Get the image of a specific sprite as base64-encoded PNG. Use vdc parameter (1 or 2) for SuperGrafx"},
        {"inputSchema", {
            {"type", "object"},
            {"properties", {
                {"sprite_index", {
                    {"type", "integer"},
                    {"description", "Sprite index (0-63)"}
                }},
                {"vdc", {
                    {"type", "integer"},
                    {"description", "VDC number (1 or 2 for SuperGrafx, default 1)"}
                }}
            }},
            {"required", json::array({"sprite_index"})}
        }}
    });

    // Disassembler tools
    tools.push_back({
        {"name", "debug_run_to_cursor"},
        {"description", "Continue execution until reaching specified logical address"},
        {"inputSchema", {
            {"type", "object"},
            {"properties", {
                {"address", {
                    {"type", "string"},
                    {"description", "Logical address in hex (e.g., 'E177')"}
                }}
            }},
            {"required", json::array({"address"})}
        }}
    });

    tools.push_back({
        {"name", "add_disassembler_bookmark"},
        {"description", "Add a bookmark in the disassembler window at specified logical address"},
        {"inputSchema", {
            {"type", "object"},
            {"properties", {
                {"address", {
                    {"type", "string"},
                    {"description", "Logical address in hex (e.g., 'E177')"}
                }},
                {"name", {
                    {"type", "string"},
                    {"description", "Bookmark name (optional, auto-generated if not provided)"}
                }}
            }},
            {"required", json::array({"address"})}
        }}
    });

    tools.push_back({
        {"name", "remove_disassembler_bookmark"},
        {"description", "Remove a bookmark from the disassembler window at specified logical address"},
        {"inputSchema", {
            {"type", "object"},
            {"properties", {
                {"address", {
                    {"type", "string"},
                    {"description", "Logical address in hex (e.g., 'E177')"}
                }}
            }},
            {"required", json::array({"address"})}
        }}
    });

    tools.push_back({
        {"name", "add_symbol"},
        {"description", "Add a symbol (label) at specified logical address with bank"},
        {"inputSchema", {
            {"type", "object"},
            {"properties", {
                {"bank", {
                    {"type", "string"},
                    {"description", "Bank number in hex (e.g., '00')"}
                }},
                {"address", {
                    {"type", "string"},
                    {"description", "Logical address in hex (e.g., 'E177')"}
                }},
                {"name", {
                    {"type", "string"},
                    {"description", "Symbol name"}
                }}
            }},
            {"required", json::array({"bank", "address", "name"})}
        }}
    });

    tools.push_back({
        {"name", "remove_symbol"},
        {"description", "Remove a symbol from specified logical address and bank"},
        {"inputSchema", {
            {"type", "object"},
            {"properties", {
                {"bank", {
                    {"type", "string"},
                    {"description", "Bank number in hex (e.g., '00')"}
                }},
                {"address", {
                    {"type", "string"},
                    {"description", "Logical address in hex (e.g., 'E177')"}
                }}
            }},
            {"required", json::array({"bank", "address"})}
        }}
    });

    // Memory editor tools
    tools.push_back({
        {"name", "select_memory_range"},
        {"description", "Select a range of 0-based offsets in a memory editor tab"},
        {"inputSchema", {
            {"type", "object"},
            {"properties", {
                {"area", {
                    {"type", "integer"},
                    {"description", "Memory editor tab ID (use list_memory_areas)"}
                }},
                {"start_address", {
                    {"type", "string"},
                    {"description", "Start 0-based offset in hex (e.g., '0100')"}
                }},
                {"end_address", {
                    {"type", "string"},
                    {"description", "End 0-based offset in hex (e.g., '01FF')"}
                }}
            }},
            {"required", json::array({"area", "start_address", "end_address"})}
        }}
    });

    tools.push_back({
        {"name", "set_memory_selection_value"},
        {"description", "Set all bytes in current memory selection to specified value. Use get_memory_selection and select_memory_range to manage selection."},
        {"inputSchema", {
            {"type", "object"},
            {"properties", {
                {"area", {
                    {"type", "integer"},
                    {"description", "Memory editor tab ID (use list_memory_areas)"}
                }},
                {"value", {
                    {"type", "string"},
                    {"description", "Byte value in hex (e.g., 'FF' or '00')"}
                }}
            }},
            {"required", json::array({"area", "value"})}
        }}
    });

    tools.push_back({
        {"name", "add_memory_bookmark"},
        {"description", "Add a bookmark in a memory area at specified address"},
        {"inputSchema", {
            {"type", "object"},
            {"properties", {
                {"area", {
                    {"type", "integer"},
                    {"description", "Memory editor tab ID (use list_memory_areas)"}
                }},
                {"address", {
                    {"type", "string"},
                    {"description", "0-based offset in hex (e.g., '0100' for byte 256 of physical memory space)"}
                }},
                {"name", {
                    {"type", "string"},
                    {"description", "Bookmark name (optional)"}
                }}
            }},
            {"required", json::array({"area", "address"})}
        }}
    });

    tools.push_back({
        {"name", "remove_memory_bookmark"},
        {"description", "Remove a bookmark from a memory area at specified address"},
        {"inputSchema", {
            {"type", "object"},
            {"properties", {
                {"area", {
                    {"type", "integer"},
                    {"description", "Memory editor tab ID (use list_memory_areas)"}
                }},
                {"address", {
                    {"type", "string"},
                    {"description", "0-based offset in hex (e.g., '0100' for byte 256 of physical memory space)"}
                }}
            }},
            {"required", json::array({"area", "address"})}
        }}
    });

    tools.push_back({
        {"name", "add_memory_watch"},
        {"description", "Add a watch (tracked memory location) in a memory area"},
        {"inputSchema", {
            {"type", "object"},
            {"properties", {
                {"area", {
                    {"type", "integer"},
                    {"description", "Memory editor tab ID (use list_memory_areas)"}
                }},
                {"address", {
                    {"type", "string"},
                    {"description", "0-based offset in hex (e.g., '0100' for byte 256 of physical memory space)"}
                }},
                {"notes", {
                    {"type", "string"},
                    {"description", "Watch notes (optional)"}
                }}
            }},
            {"required", json::array({"area", "address"})}
        }}
    });

    tools.push_back({
        {"name", "remove_memory_watch"},
        {"description", "Remove a watch from a memory area at specified address"},
        {"inputSchema", {
            {"type", "object"},
            {"properties", {
                {"area", {
                    {"type", "integer"},
                    {"description", "Memory editor tab ID (use list_memory_areas)"}
                }},
                {"address", {
                    {"type", "string"},
                    {"description", "0-based offset in hex (e.g., '0100' for byte 256 of physical memory space)"}
                }}
            }},
            {"required", json::array({"area", "address"})}
        }}
    });

    tools.push_back({
        {"name", "list_disassembler_bookmarks"},
        {"description", "List all bookmarks in the disassembler"},
        {"inputSchema", {
            {"type", "object"},
            {"properties", json::object()}
        }}
    });

    tools.push_back({
        {"name", "list_symbols"},
        {"description", "List all symbols (labels) defined in the disassembler"},
        {"inputSchema", {
            {"type", "object"},
            {"properties", json::object()}
        }}
    });

    tools.push_back({
        {"name", "get_call_stack"},
        {"description", "List the current call stack (function calls hierarchy)"},
        {"inputSchema", {
            {"type", "object"},
            {"properties", json::object()}
        }}
    });

    tools.push_back({
        {"name", "list_memory_bookmarks"},
        {"description", "List all bookmarks in a specific memory area"},
        {"inputSchema", {
            {"type", "object"},
            {"properties", {
                {"area", {
                    {"type", "integer"},
                    {"description", "Memory editor tab ID (use list_memory_areas)"}
                }}
            }},
            {"required", json::array({"area"})}
        }}
    });

    tools.push_back({
        {"name", "list_memory_watches"},
        {"description", "List all watches in a specific memory area"},
        {"inputSchema", {
            {"type", "object"},
            {"properties", {
                {"area", {
                    {"type", "integer"},
                    {"description", "Memory editor tab ID (use list_memory_areas)"}
                }}
            }},
            {"required", json::array({"area"})}
        }}
    });

    tools.push_back({
        {"name", "get_memory_selection"},
        {"description", "Get the current memory selection range for a specific memory area"},
        {"inputSchema", {
            {"type", "object"},
            {"properties", {
                {"area", {
                    {"type", "integer"},
                    {"description", "Memory editor tab ID (use list_memory_areas)"}
                }}
            }},
            {"required", json::array({"area"})}
        }}
    });

    tools.push_back({
        {"name", "memory_search_capture"},
        {"description", "Capture a snapshot of memory for comparison in searches"},
        {"inputSchema", {
            {"type", "object"},
            {"properties", {
                {"area", {
                    {"type", "integer"},
                    {"description", "Memory editor tab ID (use list_memory_areas)"}
                }}
            }},
            {"required", json::array({"area"})}
        }}
    });

    tools.push_back({
        {"name", "memory_search"},
        {"description", "Search memory for values matching criteria. Returns addresses and values found."},
        {"inputSchema", {
            {"type", "object"},
            {"properties", {
                {"area", {
                    {"type", "integer"},
                    {"description", "Memory editor tab ID (use list_memory_areas)"}
                }},
                {"operator", {
                    {"type", "string"},
                    {"description", "Comparison operator"},
                    {"enum", json::array({"<", ">", "==", "!=", "<=", ">="})}
                }},
                {"compare_type", {
                    {"type", "string"},
                    {"description", "What to compare against: 'previous' (snapshot), 'value' (specific value), or 'address' (value at specific address)"},
                    {"enum", json::array({"previous", "value", "address"})}
                }},
                {"compare_value", {
                    {"type", "integer"},
                    {"description", "Value to compare (for compare_type='value') or address to compare (for compare_type='address')"}
                }},
                {"data_type", {
                    {"type", "string"},
                    {"description", "Data type: 'unsigned' (default), 'signed', 'hex'"},
                    {"enum", json::array({"unsigned", "signed", "hex"})}
                }}
            }},
            {"required", json::array({"area", "operator", "compare_type"})}
        }}
    });

    json response;
    response["jsonrpc"] = "2.0";
    response["id"] = id;
    response["result"] = {
        {"tools", tools}
    };

    SendResponse(response);
}

void McpServer::HandleToolsCall(const json& request)
{
    if (!request.contains("id"))
    {
        SendError(0, -32600, "Invalid Request: missing id");
        return;
    }

    int64_t id = request["id"];

    if (!request.contains("params") || !request["params"].contains("name"))
    {
        SendError(id, -32602, "Invalid params: missing tool name");
        return;
    }

    std::string toolName = request["params"]["name"];
    json arguments = request["params"].contains("arguments") ? request["params"]["arguments"] : json::object();

    // Enqueue command for main thread to execute
    DebugCommand* cmd = new DebugCommand();
    cmd->requestId = id;
    cmd->toolName = toolName;
    cmd->arguments = arguments;
    m_commandQueue.Push(cmd);
}

static int GetBreakpointTypeFromString(const std::string& memory_area)
{
    if (memory_area == "rom_ram") return HuC6280::HuC6280_BREAKPOINT_TYPE_ROMRAM;
    if (memory_area == "vram") return HuC6280::HuC6280_BREAKPOINT_TYPE_VRAM;
    if (memory_area == "palette") return HuC6280::HuC6280_BREAKPOINT_TYPE_PALETTE_RAM;
    if (memory_area == "huc6270_reg") return HuC6280::HuC6280_BREAKPOINT_TYPE_HUC6270_REGISTER;
    if (memory_area == "huc6260_reg") return HuC6280::HuC6280_BREAKPOINT_TYPE_HUC6260_REGISTER;
    return HuC6280::HuC6280_BREAKPOINT_TYPE_ROMRAM; // default
}

json McpServer::ExecuteCommand(const std::string& toolName, const json& arguments)
{
    // Normalize tool name: VS Code converts underscores to dots
    std::string normalizedTool = toolName;
    size_t pos = 0;
    while ((pos = normalizedTool.find('.', pos)) != std::string::npos) {
        normalizedTool[pos] = '_';
        pos++;
    }

    // Execution control
    if (normalizedTool == "debug_pause")
    {
        m_debugAdapter.Pause();
        return {{"success", true}};
    }
    else if (normalizedTool == "debug_continue")
    {
        m_debugAdapter.Resume();
        return {{"success", true}};
    }
    else if (normalizedTool == "debug_step_into")
    {
        m_debugAdapter.StepInto();
        return {{"success", true}};
    }
    else if (normalizedTool == "debug_step_over")
    {
        m_debugAdapter.StepOver();
        return {{"success", true}};
    }
    else if (normalizedTool == "debug_step_out")
    {
        m_debugAdapter.StepOut();
        return {{"success", true}};
    }
    else if (normalizedTool == "debug_step_frame")
    {
        m_debugAdapter.StepFrame();
        return {{"success", true}};
    }
    else if (normalizedTool == "debug_reset")
    {
        m_debugAdapter.Reset();
        return {{"success", true}};
    }
    else if (normalizedTool == "debug_get_status")
    {
        return m_debugAdapter.GetDebugStatus();
    }
    // Breakpoints
    else if (normalizedTool == "set_breakpoint")
    {
        std::string addrStr = arguments["address"];
        u16 address;
        if (!parse_hex_with_prefix(addrStr, &address))
            return {{"error", "Invalid address format"}};

        std::string memory_area = arguments.value("memory_area", "rom_ram");
        int breakpoint_type = GetBreakpointTypeFromString(memory_area);

        std::string type = arguments.value("type", "exec");
        bool read = (type == "read");
        bool write = (type == "write");
        bool execute = (type == "exec");

        m_debugAdapter.SetBreakpoint(address, breakpoint_type, read, write, execute);
        return {{"success", true}, {"address", addrStr}, {"memory_area", memory_area}};
    }
    else if (normalizedTool == "set_breakpoint_range")
    {
        std::string startAddrStr = arguments["start_address"];
        std::string endAddrStr = arguments["end_address"];
        u16 start_address, end_address;

        if (!parse_hex_with_prefix(startAddrStr, &start_address))
            return {{"error", "Invalid start_address format"}};
        if (!parse_hex_with_prefix(endAddrStr, &end_address))
            return {{"error", "Invalid end_address format"}};
        if (start_address > end_address)
            return {{"error", "start_address must be <= end_address"}};

        std::string memory_area = arguments.value("memory_area", "rom_ram");
        int breakpoint_type = GetBreakpointTypeFromString(memory_area);

        std::string type = arguments.value("type", "exec");
        bool read = (type == "read");
        bool write = (type == "write");
        bool execute = (type == "exec");

        m_debugAdapter.SetBreakpointRange(start_address, end_address, breakpoint_type,
                                         read, write, execute);
        return {{"success", true}, {"start_address", startAddrStr}, {"end_address", endAddrStr}, {"memory_area", memory_area}};
    }
    else if (normalizedTool == "remove_breakpoint")
    {
        std::string addrStr = arguments["address"];
        u16 address;
        if (!parse_hex_with_prefix(addrStr, &address))
            return {{"error", "Invalid address format"}};

        std::string memory_area = arguments.value("memory_area", "rom_ram");
        int breakpoint_type = GetBreakpointTypeFromString(memory_area);

        // Check if end_address is provided for range breakpoints
        u16 end_address = 0;
        if (arguments.contains("end_address"))
        {
            std::string endAddrStr = arguments["end_address"];
            if (!parse_hex_with_prefix(endAddrStr, &end_address))
                return {{"error", "Invalid end_address format"}};
        }

        m_debugAdapter.ClearBreakpointByAddress(address, breakpoint_type, end_address);
        return {{"success", true}, {"address", addrStr}, {"memory_area", memory_area}};
    }
    else if (normalizedTool == "list_breakpoints")
    {
        std::vector<BreakpointInfo> breakpoints = m_debugAdapter.ListBreakpoints();
        json bpArray = json::array();
        for (const BreakpointInfo& bp : breakpoints)
        {
            json bpObj;
            bpObj["enabled"] = bp.enabled;
            bpObj["type"] = bp.type_name;

            std::ostringstream addr_ss;
            addr_ss << std::hex << std::uppercase << std::setfill('0') << std::setw(4) << bp.address1;
            bpObj["address"] = addr_ss.str();

            if (bp.range)
            {
                std::ostringstream addr2_ss;
                addr2_ss << std::hex << std::uppercase << std::setfill('0') << std::setw(4) << bp.address2;
                bpObj["address2"] = addr2_ss.str();
            }

            bpObj["read"] = bp.read;
            bpObj["write"] = bp.write;
            bpObj["execute"] = bp.execute;
            bpArray.push_back(bpObj);
        }
        return {{"breakpoints", bpArray}};
    }
    // Memory
    else if (normalizedTool == "list_memory_areas")
    {
        std::vector<MemoryAreaInfo> areas = m_debugAdapter.ListMemoryAreas();
        json areaArray = json::array();
        for (const MemoryAreaInfo& area : areas)
        {
            json areaObj;
            areaObj["id"] = area.id;
            areaObj["name"] = area.name;
            areaObj["size"] = area.size;
            areaArray.push_back(areaObj);
        }
        return {{"areas", areaArray}};
    }
    else if (normalizedTool == "read_memory")
    {
        int area = arguments["area"];
        std::string offsetStr = arguments["offset"];
        u32 offset;
        if (!parse_hex_with_prefix(offsetStr, &offset))
            return {{"error", "Invalid offset format"}};

        size_t size = arguments["size"];
        std::vector<u8> data = m_debugAdapter.ReadMemoryArea(area, offset, size);

        std::ostringstream hex_ss;
        for (size_t i = 0; i < data.size(); i++)
        {
            hex_ss << std::hex << std::uppercase << std::setfill('0') << std::setw(2) << (int)data[i];
            if (i < data.size() - 1)
                hex_ss << " ";
        }

        return {{"area", area}, {"offset", offsetStr}, {"data", hex_ss.str()}};
    }
    else if (normalizedTool == "write_memory")
    {
        int area = arguments["area"];
        std::string offsetStr = arguments["offset"];
        u32 offset;
        if (!parse_hex_with_prefix(offsetStr, &offset))
            return {{"error", "Invalid offset format"}};

        std::string bytesStr = arguments["bytes"];
        std::vector<u8> data;

        // Parse hex bytes
        std::istringstream iss(bytesStr);
        std::string byteStr;
        while (iss >> byteStr)
        {
            u8 byte;
            if (!parse_hex_with_prefix(byteStr, &byte))
                return {{"error", "Invalid byte format"}};
            data.push_back(byte);
        }

        m_debugAdapter.WriteMemoryArea(area, offset, data);
        return {{"success", true}, {"area", area}, {"offset", offsetStr}, {"bytes_written", data.size()}};
    }
    // Registers
    else if (normalizedTool == "write_huc6280_register")
    {
        std::string name = arguments["name"];
        std::string valueStr = arguments["value"];
        u32 value;
        if (!parse_hex_with_prefix(valueStr, &value))
            return {{"error", "Invalid value format"}};

        m_debugAdapter.SetRegister(name, value);
        return {{"success", true}, {"register", name}, {"value", valueStr}};
    }
    // Disassembly
    else if (normalizedTool == "get_disassembly")
    {
        if (!arguments.contains("start_address"))
            return {{"error", "start_address is required"}};
        if (!arguments.contains("end_address"))
            return {{"error", "end_address is required"}};

        std::string startAddrStr = arguments["start_address"];
        std::string endAddrStr = arguments["end_address"];
        u16 start_address, end_address;

        if (!parse_hex_with_prefix(startAddrStr, &start_address))
            return {{"error", "Invalid start_address format"}};
        if (!parse_hex_with_prefix(endAddrStr, &end_address))
            return {{"error", "Invalid end_address format"}};
        if (start_address > end_address)
            return {{"error", "start_address must be <= end_address"}};

        // Optional bank parameter (-1 means use current MPR mappings)
        int bank = -1;
        if (arguments.contains("bank"))
        {
            std::string bankStr = arguments["bank"];
            u8 bank_value;
            if (!parse_hex_with_prefix(bankStr, &bank_value))
                return {{"error", "Invalid bank format (must be 00-FF in hex)"}};
            bank = bank_value;
        }

        std::vector<DisasmLine> lines = m_debugAdapter.GetDisassembly(start_address, end_address, bank);

        json result;
        json instructions = json::array();

        for (const DisasmLine& line : lines)
        {
            json instr;
            std::ostringstream addr_ss, bank_ss, jump_ss;

            addr_ss << std::hex << std::uppercase << std::setfill('0') << std::setw(4) << line.address;
            bank_ss << std::hex << std::uppercase << std::setfill('0') << std::setw(2) << (int)line.bank;

            instr["address"] = addr_ss.str();
            instr["bank"] = bank_ss.str();
            instr["segment"] = line.segment;
            instr["instruction"] = line.name;
            instr["bytes"] = line.bytes;
            instr["size"] = line.size;

            if (line.jump)
            {
                jump_ss << std::hex << std::uppercase << std::setfill('0') << std::setw(4) << line.jump_address;
                instr["jump_target"] = jump_ss.str();
                instr["is_subroutine"] = line.subroutine;
            }

            if (line.irq > 0)
            {
                instr["irq"] = line.irq;
            }

            instructions.push_back(instr);
        }

        result["instructions"] = instructions;
        result["count"] = lines.size();
        result["start_address"] = startAddrStr;
        result["end_address"] = endAddrStr;
        if (bank >= 0)
        {
            std::ostringstream bank_ss;
            bank_ss << std::hex << std::uppercase << std::setfill('0') << std::setw(2) << bank;
            result["bank"] = bank_ss.str();
        }

        if (lines.empty())
        {
            result["note"] = "No disassembly records found. You may have asked for code that has not been executed yet. Code is only disassembled as it is executed.";
        }

        return result;
    }
    // Media info
    else if (normalizedTool == "get_media_info")
    {
        return m_debugAdapter.GetMediaInfo();
    }
    // Chip status
    else if (normalizedTool == "get_huc6280_status")
    {
        return m_debugAdapter.GetHuC6280Status();
    }
    else if (normalizedTool == "get_huc6270_registers")
    {
        int vdc = arguments.value("vdc", 1);
        return m_debugAdapter.GetHuC6270Registers(vdc);
    }
    else if (normalizedTool == "write_huc6270_register")
    {
        int reg = arguments["register"];
        std::string valueStr = arguments["value"];
        int vdc = arguments.value("vdc", 1);

        u16 value;
        if (!parse_hex_with_prefix(valueStr, &value))
            return {{"error", "Invalid value format"}};
        
        return m_debugAdapter.WriteHuC6270Register(vdc, reg, value);
    }
    else if (normalizedTool == "get_huc6270_status")
    {
        int vdc = arguments.value("vdc", 1);
        return m_debugAdapter.GetHuC6270Status(vdc);
    }
    else if (normalizedTool == "get_huc6260_status")
    {
        return m_debugAdapter.GetHuC6260Status();
    }
    else if (normalizedTool == "get_huc6202_status")
    {
        return m_debugAdapter.GetHuC6202Status();
    }
    else if (normalizedTool == "get_psg_status")
    {
        return m_debugAdapter.GetPSGStatus();
    }
    else if (normalizedTool == "get_cdrom_status")
    {
        return m_debugAdapter.GetCDROMStatus();
    }
    else if (normalizedTool == "get_arcade_card_status")
    {
        return m_debugAdapter.GetArcadeCardStatus();
    }
    else if (normalizedTool == "get_cdrom_audio_status")
    {
        return m_debugAdapter.GetCDROMAudioStatus();
    }
    else if (normalizedTool == "get_adpcm_status")
    {
        return m_debugAdapter.GetADPCMStatus();
    }
    else if (normalizedTool == "get_screenshot")
    {
        return m_debugAdapter.GetScreenshot();
    }
    // Media and state management
    else if (normalizedTool == "load_media")
    {
        std::string file_path = arguments["file_path"];
        return m_debugAdapter.LoadMedia(file_path);
    }
    else if (normalizedTool == "load_symbols")
    {
        std::string file_path = arguments["file_path"];
        return m_debugAdapter.LoadSymbols(file_path);
    }
    else if (normalizedTool == "list_save_state_slots")
    {
        return m_debugAdapter.ListSaveStateSlots();
    }
    else if (normalizedTool == "select_save_state_slot")
    {
        int slot = arguments["slot"];
        return m_debugAdapter.SelectSaveStateSlot(slot);
    }
    else if (normalizedTool == "save_state")
    {
        return m_debugAdapter.SaveState();
    }
    else if (normalizedTool == "load_state")
    {
        return m_debugAdapter.LoadState();
    }
    else if (normalizedTool == "set_fast_forward_speed")
    {
        int speed = arguments["speed"];
        return m_debugAdapter.SetFastForwardSpeed(speed);
    }
    else if (normalizedTool == "toggle_fast_forward")
    {
        bool enabled = arguments["enabled"];
        return m_debugAdapter.ToggleFastForward(enabled);
    }
    else if (normalizedTool == "controller_button")
    {
        int player = arguments["player"];
        std::string button = arguments["button"];
        std::string action = arguments["action"];
        return m_debugAdapter.ControllerButton(player, button, action);
    }
    else if (normalizedTool == "controller_set_type")
    {
        int player = arguments["player"];
        std::string type = arguments["type"];
        return m_debugAdapter.ControllerSetType(player, type);
    }
    else if (normalizedTool == "controller_set_turbo_tap")
    {
        bool enabled = arguments["enabled"];
        return m_debugAdapter.ControllerSetTurboTap(enabled);
    }
    else if (normalizedTool == "controller_get_type")
    {
        int player = arguments["player"];
        return m_debugAdapter.ControllerGetType(player);
    }
    else if (normalizedTool == "list_sprites")
    {
        int vdc = arguments.value("vdc", 1);
        return m_debugAdapter.ListSprites(vdc);
    }
    else if (normalizedTool == "get_sprite_image")
    {
        int sprite_index = arguments.value("sprite_index", 0);
        int vdc = arguments.value("vdc", 1);
        return m_debugAdapter.GetSpriteImage(sprite_index, vdc);
    }
    // Disassembler operations
    else if (normalizedTool == "debug_run_to_cursor")
    {
        std::string addrStr = arguments["address"];
        u16 address;
        if (!parse_hex_with_prefix(addrStr, &address))
            return {{"error", "Invalid address format"}};
        return m_debugAdapter.RunToAddress(address);
    }
    else if (normalizedTool == "add_disassembler_bookmark")
    {
        std::string addrStr = arguments["address"];
        u16 address;
        if (!parse_hex_with_prefix(addrStr, &address))
            return {{"error", "Invalid address format"}};
        std::string name = arguments.value("name", "");
        return m_debugAdapter.AddDisassemblerBookmark(address, name);
    }
    else if (normalizedTool == "remove_disassembler_bookmark")
    {
        std::string addrStr = arguments["address"];
        u16 address;
        if (!parse_hex_with_prefix(addrStr, &address))
            return {{"error", "Invalid address format"}};
        return m_debugAdapter.RemoveDisassemblerBookmark(address);
    }
    else if (normalizedTool == "add_symbol")
    {
        std::string bankStr = arguments["bank"];
        std::string addrStr = arguments["address"];
        std::string name = arguments["name"];
        u8 bank;
        u16 address;
        if (!parse_hex_with_prefix(bankStr, &bank))
            return {{"error", "Invalid bank format"}};
        if (!parse_hex_with_prefix(addrStr, &address))
            return {{"error", "Invalid address format"}};
        return m_debugAdapter.AddSymbol(bank, address, name);
    }
    else if (normalizedTool == "remove_symbol")
    {
        std::string bankStr = arguments["bank"];
        std::string addrStr = arguments["address"];
        u8 bank;
        u16 address;
        if (!parse_hex_with_prefix(bankStr, &bank))
            return {{"error", "Invalid bank format"}};
        if (!parse_hex_with_prefix(addrStr, &address))
            return {{"error", "Invalid address format"}};
        return m_debugAdapter.RemoveSymbol(bank, address);
    }
    // Memory editor operations
    else if (normalizedTool == "select_memory_range")
    {
        int editor = arguments["area"];
        std::string startStr = arguments["start_address"];
        std::string endStr = arguments["end_address"];
        u32 start_address, end_address;
        if (!parse_hex_with_prefix(startStr, &start_address))
            return {{"error", "Invalid start_address format"}};
        if (!parse_hex_with_prefix(endStr, &end_address))
            return {{"error", "Invalid end_address format"}};
        return m_debugAdapter.SelectMemoryRange(editor, start_address, end_address);
    }
    else if (normalizedTool == "set_memory_selection_value")
    {
        int editor = arguments["area"];
        std::string valueStr = arguments["value"];
        u8 value;
        if (!parse_hex_with_prefix(valueStr, &value))
            return {{"error", "Invalid value format"}};
        return m_debugAdapter.SetMemorySelectionValue(editor, value);
    }
    else if (normalizedTool == "add_memory_bookmark")
    {
        int editor = arguments["area"];
        std::string addrStr = arguments["address"];
        std::string name = arguments.value("name", "");
        u32 address;
        if (!parse_hex_with_prefix(addrStr, &address))
            return {{"error", "Invalid address format"}};
        return m_debugAdapter.AddMemoryBookmark(editor, address, name);
    }
    else if (normalizedTool == "remove_memory_bookmark")
    {
        int editor = arguments["area"];
        std::string addrStr = arguments["address"];
        u32 address;
        if (!parse_hex_with_prefix(addrStr, &address))
            return {{"error", "Invalid address format"}};
        return m_debugAdapter.RemoveMemoryBookmark(editor, address);
    }
    else if (normalizedTool == "add_memory_watch")
    {
        int editor = arguments["area"];
        std::string addrStr = arguments["address"];
        std::string notes = arguments.value("notes", "");
        u32 address;
        if (!parse_hex_with_prefix(addrStr, &address))
            return {{"error", "Invalid address format"}};
        return m_debugAdapter.AddMemoryWatch(editor, address, notes);
    }
    else if (normalizedTool == "remove_memory_watch")
    {
        int editor = arguments["area"];
        std::string addrStr = arguments["address"];
        u32 address;
        if (!parse_hex_with_prefix(addrStr, &address))
            return {{"error", "Invalid address format"}};
        return m_debugAdapter.RemoveMemoryWatch(editor, address);
    }
    else if (normalizedTool == "list_disassembler_bookmarks")
    {
        return m_debugAdapter.ListDisassemblerBookmarks();
    }
    else if (normalizedTool == "list_symbols")
    {
        return m_debugAdapter.ListSymbols();
    }
    else if (normalizedTool == "get_call_stack")
    {
        return m_debugAdapter.ListCallStack();
    }
    else if (normalizedTool == "list_memory_bookmarks")
    {
        int area = arguments["area"];
        return m_debugAdapter.ListMemoryBookmarks(area);
    }
    else if (normalizedTool == "list_memory_watches")
    {
        int area = arguments["area"];
        return m_debugAdapter.ListMemoryWatches(area);
    }
    else if (normalizedTool == "get_memory_selection")
    {
        int area = arguments["area"];
        return m_debugAdapter.GetMemorySelection(area);
    }
    else if (normalizedTool == "memory_search_capture")
    {
        int area = arguments["area"];
        return m_debugAdapter.MemorySearchCapture(area);
    }
    else if (normalizedTool == "memory_search")
    {
        int area = arguments["area"];
        std::string op = arguments["operator"];
        std::string compare_type = arguments["compare_type"];
        int compare_value = arguments.value("compare_value", 0);
        std::string data_type = arguments.value("data_type", "unsigned");
        return m_debugAdapter.MemorySearch(area, op, compare_type, compare_value, data_type);
    }
    else
    {
        return {{"error", "Unknown tool: " + toolName}};
    }
}

void McpServer::SendResponse(const json& response)
{
    std::string line = response.dump();
    m_transport->send(line);
}

void McpServer::SendError(int64_t id, int code, const std::string& message, const json& data)
{
    json error;
    error["jsonrpc"] = "2.0";
    error["id"] = id;
    error["error"] = {
        {"code", code},
        {"message", message}
    };

    if (!data.empty() && !data.is_null())
    {
        error["error"]["data"] = data;
    }

    Log("[MCP] Sending error: %s", error.dump().c_str());

    SendResponse(error);
}

void McpServer::LoadResources()
{
    char exe_path[1024];
    get_executable_path(exe_path, sizeof(exe_path));

    if (exe_path[0] == '\0')
        return;

    std::string base_path = exe_path;
    std::string resourcesPath = base_path + "/mcp/resources";

    LoadResourcesFromCategory("hardware", resourcesPath + "/hardware/toc.json");
}

void McpServer::LoadResourcesFromCategory(const std::string& category, const std::string& tocPath)
{
    // Read toc.json file
    std::ifstream file(tocPath);
    if (!file.is_open())
    {
        // Resources directory not found, silently skip
        Log("[MCP] Warning: Resources TOC file not found: %s", tocPath.c_str());
        return;
    }

    std::stringstream buffer;
    buffer << file.rdbuf();
    std::string content = buffer.str();
    file.close();

    if (!json::accept(content))
    {
        Log("[MCP] Warning: Invalid JSON in resources TOC file: %s", tocPath.c_str());
        return;
    }

    json toc = json::parse(content);
    
    if (!toc.contains("toc") || !toc["toc"].is_array())
    {
        Log("[MCP] Warning: Invalid TOC format in resources TOC file: %s", tocPath.c_str());
        return;
    }

    // Get the directory containing toc.json
    std::string tocDir = tocPath.substr(0, tocPath.find_last_of("/\\"));

    for (const json& item : toc["toc"])
    {
        if (!item.contains("uri") || !item.contains("title"))
            continue;

        ResourceInfo resource;
        resource.uri = "geargrafx://" + category + "/" + item["uri"].get<std::string>();
        resource.title = item["title"].get<std::string>();
        resource.description = item.contains("description") ? item["description"].get<std::string>() : "";
        resource.mimeType = item.contains("mimeType") ? item["mimeType"].get<std::string>() : "text/plain";
        resource.category = category;
        resource.filePath = tocDir + "/" + item["uri"].get<std::string>() + ".md";

        m_resources.push_back(resource);
        m_resourceMap[resource.uri] = resource;
    }
}

std::string McpServer::ReadFileContents(const std::string& filePath)
{
    std::ifstream file(filePath);
    if (!file.is_open())
    {
        Log("[MCP] Warning: Failed to open resource file: %s", filePath.c_str());
        return "";
    }

    std::stringstream buffer;
    buffer << file.rdbuf();
    return buffer.str();
}

void McpServer::HandleResourcesList(const json& request)
{
    if (!request.contains("id"))
    {
        SendError(0, -32600, "Invalid Request: missing id");
        return;
    }

    int64_t id = request["id"];

    json resources = json::array();

    for (const ResourceInfo& resource : m_resources)
    {
        json resourceJson;
        resourceJson["uri"] = resource.uri;
        resourceJson["name"] = resource.title;
        resourceJson["description"] = resource.description;
        resourceJson["mimeType"] = resource.mimeType;

        resources.push_back(resourceJson);
    }

    json response;
    response["jsonrpc"] = "2.0";
    response["id"] = id;
    response["result"] = {
        {"resources", resources}
    };

    SendResponse(response);
}

void McpServer::HandleResourcesRead(const json& request)
{
    if (!request.contains("id"))
    {
        SendError(0, -32600, "Invalid Request: missing id");
        return;
    }

    int64_t id = request["id"];

    if (!request.contains("params") || !request["params"].contains("uri"))
    {
        SendError(id, -32602, "Invalid params: missing uri");
        return;
    }

    std::string uri = request["params"]["uri"];

    // Find resource
    std::map<std::string, ResourceInfo>::const_iterator it = m_resourceMap.find(uri);
    if (it == m_resourceMap.end())
    {
        SendError(id, -32602, "Resource not found: " + uri);
        return;
    }

    const ResourceInfo& resource = it->second;
    std::string content = ReadFileContents(resource.filePath);

    if (content.empty())
    {
        SendError(id, -32602, "Failed to read resource file: " + resource.filePath);
        return;
    }

    json response;
    response["jsonrpc"] = "2.0";
    response["id"] = id;
    response["result"] = {
        {"contents", json::array({
            {
                {"uri", resource.uri},
                {"mimeType", resource.mimeType},
                {"text", content}
            }
        })}
    };

    SendResponse(response);
}

